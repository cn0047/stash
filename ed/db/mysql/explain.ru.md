EXPLAIN
-

Example:

````sql
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | test  | NULL       | index | NULL          | PRIMARY | 4       | NULL |    1 |   100.00 | Using index |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
````

`key_len` - length of the key that MySQL decided to use.
Determine how many parts of a multiple-part key MySQL actually uses.

`filtered` - estimated percentage of table rows that will be filtered by the table condition.
100.00 - good.

## Column type

В руководстве по MySQL сказано, что в этом столбце отражается «тип
соединения», но нам кажется, что следует говорить скорее о методе
доступа, иными словами, о том, как MySQL решила искать строки в таб
лице. Перечислим наиболее важные методы доступа в порядке от наихудшего
к наилучшему.Столбцы результата команды EXPLAIN

**ALL**

Этот подход обычно называют **сканированием таблицы**. В общем
случае речь идет о том, что MySQL должна просмотреть таблицу от
начала до конца, чтобы найти нужную строку. Существуют исключения,
например запросы с фразой LIMIT или запросы, для которых
в столбце Extra отображается значение «Using distinct/not exists».

**index**

То же, что сканирование таблицы, только MySQL просматривает ее
**в порядке, задаваемом индексом**, а не в порядке следования строк.
Основное преимущество заключается в том, что не требуется сортировка;
недостаток же – высокая стоимость чтения всей таблицы
в порядке, задаваемом индексом. Обычно это означает, что строки
выбираются произвольным образом, что крайне накладно.
Если в столбце Extra при этом находится значение «Using index»,
значит, MySQL использует покрывающий индекс
и просматривает только данные в индексе, не обращаясь к строкам. Это
гораздо дешевле, чем сканирование таблицы в задаваемом индексе.

**range**

**Просмотр диапазона** – это ограниченная форма сканирования индекса.
Просмотр начинается в определенной точке индекса и возвращает
строки в некотором диапазоне значений. Это лучше, чем
полное сканирование, так как не приходится перебирать индекс целиком.
Очевидные примеры просмотра диапазона – запросы с условиями
BETWEEN или > во фразе WHERE.
Когда MySQL использует индекс для поиска в списке значений, например,
при вычислении предиката IN() или условий, объединенных
связкой OR, также применяется просмотр диапазона. Однако это совершенно
разные методы доступа с иными характеристиками производительности.
К этому методу применимы те же самые соображения о стоимости,
что и к методу index.

**ref**

Это доступ по индексу (иногда он называется поиском по индексу
(index lookup)), в результате которого **возвращаются строки, соответствующие
единственному заданному значению**. Но таких строк может
быть несколько, поэтому поиск сочетается с просмотром. Данный
тип доступа возможен лишь в случае неуникального индекса
или неуникального префикса ключа в уникальном индексе. Он называется ref,
потому что значения ключей в индексе сравниваются
с некоторой справочной (reference) величиной. Справочная величина
может быть как константой, так и значением из предыдущей
таблицы, если в запросе участвует несколько таблиц.
Одним из вариантов ref является тип доступа ref_or_null. В этом случае
MySQL должна выполнить второй просмотр для поиска записей
с ключом NULL.

**eq_ref**

Это поиск по индексу в случае, когда MySQL точно знает, что **будет
возвращено не более одного значения**. Такой метод доступа применяется,
когда MySQL решает использовать первичный ключ или
уникальный индекс для сравнения на равенство с некоторой справочной
величиной. Этот тип доступа MySQL умеет отлично оптимизировать,
так как заранее известно, что не придется просматривать
диапазоны отвечающих условию строк или искать дополнительные
строки после того, как одна уже найдена.

**const, system**

Эти типы доступа MySQL применяет, когда в процессе оптимизации
какую-то часть запроса **можно преобразовать в константу**. Например,
если вы выбираете первичный ключ строки и помещаете его в условие WHERE,
то MySQL может преобразовать этот запрос в константу.
Затем соответствующая таблица по существу удаляется из операции
соединения.

**NULL**

Этот метод означает, что MySQL сумела разрешить запрос **на фазе
оптимизации**, так что в ходе выполнения вообще не потребуется обращаться
к таблице или индексу. Например, для выборки минимального
значения проиндексированного столбца достаточно просмотреть
только индекс, не обращаясь к таблице.
