/*
npm install async

waterfall
    Функции вызываются по очереди, а результаты вызова всех функций пере-
    даются в виде массива последней функции обратного вызова (другие назва-
    ния этого паттерна: series и sequence ).
series
    Функции вызываются по очереди, а (не обязательно) результаты передаются
    в виде массива последней функции обратного вызова.
parallel
    Функции запускаются параллельно, а затем завершаются, результаты переда-
    ются последней функции обратного вызова (но результирующий массив в не-
    которых интерпретациях параллельного паттерна его частью не является).
whilst
    Осуществляет повторяющийся вызов одной функции, активизирующей
    последнюю функцию обратного вызова, только если предварительный тест
    выдает значение false или случается ошибка.
queue
    Вызывает функции в параллельном режиме вплоть до заданного ограниче-
    ния параллельности, и новые функции выстраиваются в очередь, пока одна
    из функций не завершит свою работу.
until
    Осуществляет повторяющийся вызов одной функции, активизирующей по­
    следнюю функцию обратного вызова, только если последующий тест выдает
    значение false или случается ошибка.
auto
    Функции вызываются по требованию, каждая функция получает результаты
    предыдущих функций обратного вызова.
iterator
    Каждая функция вызывает следующую функцию, при этом имеется возмож-
    ность индивидуального доступа к следующему итератору.
apply
    Функция продленного действия с уже применяемыми аргументами, вступа-
    ющая во взаимодействие с другими функциями потока управления.
nextTick
    Вызов функции обратного вызова на следующем проходе цикла обработки
    событий основан на применении Node-метода process.nextTick .
*/
var fs = require('fs'),
    async = require('async');
try {
    async.waterfall([
        function readData(callback) {
            fs.readFile('./data/data1.txt', 'utf8', function(err, data){
                callback(err,data);
            });
        },
        function modify(text, callback) {
            var adjdata=text.replace(/somecompany\.com/g,'burningbird.net');
            callback(null, adjdata);
        },
        function writeData(text, callback) {
            fs.writeFile('./data/data1.txt', text, function(err) {
                callback(err,text);
            });
        }
    ], function (err, result) {
        if (err) throw err;
            console.log(result);
    });
} catch(err) {
    console.log(err);
}